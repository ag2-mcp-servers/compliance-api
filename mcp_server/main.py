# generated by fastapi-codegen:
#   filename:  openapi.yaml
#   timestamp: 2025-06-28T18:51:04+00:00



import argparse
import json
import os
from typing import *
from typing import Optional

from autogen.mcp.mcp_proxy import MCPProxy
from autogen.mcp.mcp_proxy.security import BaseSecurity, UnsuportedSecurityStub
from fastapi import Header

from models import (
    ComplianceSummary,
    PagedComplianceViolationCollection,
    SuppressViolationRequest,
)

app = MCPProxy(
    contact={'name': 'eBay Inc,', 'x-twitter': 'ebay'},
    description='Service for providing information to sellers about their listings being non-compliant, or at risk for becoming non-compliant, against eBay listing policies.',
    license={
        'name': 'eBay API License Agreement',
        'url': 'https://go.developer.ebay.com/api-license-agreement',
    },
    title='Compliance API',
    version='1.4.1',
    servers=[
        {
            'description': 'Production',
            'url': 'https://api.ebay.com{basePath}',
            'variables': {'basePath': {'default': '/sell/compliance/v1'}},
        }
    ],
)


@app.get(
    '/listing_violation',
    description=""" This call returns specific listing violations for the supported listing compliance types. Only one compliance type can be passed in per call, and the response will include all the listing violations for this compliance type, and listing violations are grouped together by eBay listing ID. See ComplianceTypeEnum for more information on the supported listing compliance types. This method also has pagination control. Note: A maximum of 2000 listing violations will be returned in a result set. If the seller has more than 2000 listing violations, some/all of those listing violations must be corrected before additional listing violations will be retrieved. The user should pay attention to the total value in the response. If this value is '2000', it is possible that the seller has more than 2000 listing violations, but this field maxes out at 2000. Note: In a future release of this API, the seller will be able to pass in a specific eBay listing ID as a query parameter to see if this specific listing has any violations. Note: Only mocked non-compliant listing data will be returned for this call in the Sandbox environment, and not specific to the seller. However, the user can still use this mock data to experiment with the compliance type filters and pagination control. """,
    tags=['listing_violation_handling'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_listing_violations(
    x__e_b_a_y__c__m_a_r_k_e_t_p_l_a_c_e__i_d: str = Header(
        ..., alias='X-EBAY-C-MARKETPLACE-ID'
    ),
    compliance_type: Optional[str] = None,
    offset: Optional[str] = None,
    listing_id: Optional[str] = None,
    limit: Optional[str] = None,
    filter: Optional[str] = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/listing_violation_summary',
    description=""" This call returns listing violation counts for a seller. A user can pass in one or more compliance types through the compliance_type query parameter. See ComplianceTypeEnum for more information on the supported listing compliance types. Listing violations are returned for multiple marketplaces if the seller sells on multiple eBay marketplaces. Note: Only a canned response, with counts for all listing compliance types, is returned in the Sandbox environment. Due to this limitation, the compliance_type query parameter (if used) will not have an effect on the response. """,
    tags=['listing_violation_handling'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_listing_violations_summary(
    x__e_b_a_y__c__m_a_r_k_e_t_p_l_a_c_e__i_d: Optional[str] = Header(
        None, alias='X-EBAY-C-MARKETPLACE-ID'
    ),
    compliance_type: Optional[str] = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/suppress_listing_violation',
    description=""" This call suppresses a listing violation for a specific listing. Only listing violations in the AT_RISK state (returned in the violations.complianceState field of the getListingViolations call) can be suppressed. Note: At this time, the suppressViolation call only supports the suppressing of ASPECTS_ADOPTION listing violations in the AT_RISK state. In the future, it is possible that this method can be used to suppress other listing violation types. A successful call returns a http status code of 204 Success. There is no response payload. If the call is not successful, an error code will be returned stating the issue. """,
    tags=['listing_violation_handling'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def suppress_violation(body: SuppressViolationRequest):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="MCP Server")
    parser.add_argument(
        "transport",
        choices=["stdio", "sse", "streamable-http"],
        help="Transport mode (stdio, sse or streamable-http)",
    )
    args = parser.parse_args()

    if "CONFIG_PATH" in os.environ:
        config_path = os.environ["CONFIG_PATH"]
        app.load_configuration(config_path)

    if "CONFIG" in os.environ:
        config = os.environ["CONFIG"]
        app.load_configuration_from_string(config)

    if "SECURITY" in os.environ:
        security_params = BaseSecurity.parse_security_parameters_from_env(
            os.environ,
        )

        app.set_security_params(security_params)

    mcp_settings = json.loads(os.environ.get("MCP_SETTINGS", "{}"))

    app.get_mcp(**mcp_settings).run(transport=args.transport)
